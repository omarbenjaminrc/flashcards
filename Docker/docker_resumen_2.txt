# Este archivo contiene flashcards de Docker Nivel 2 para Anki.
# Cubre Dockerfiles, Volúmenes y Networking.
# Separador de campos: ;
# Deck: (Puedes especificarlo al importar)
# Tipo de Nota: Básico (Front and Back)

<p>¿Qué es un <strong>Dockerfile</strong>?</p>
<p>¿Para qué lo usa un desarrollador?</p>;<h3>Dockerfile</h3><p>Es un archivo de texto con <strong>instrucciones paso a paso</strong> para <strong>construir una Imagen Docker personalizada</strong>.</p><p>Los desarrolladores lo usan para empaquetar **su propio código**, dependencias y configuraciones en una imagen portable y reproducible.</p><p><em>Analogy: La receta o instrucciones detalladas para tu plano de aplicación personalizado.</em></p>
<p>¿Cuál es el comando principal para <strong>construir una imagen</strong> a partir de un Dockerfile?</p>;<h3><code>docker build [OPCIONES] RUTA_DEL_CONTEXTO</code></h3><p>Lee el <code>Dockerfile</code> en la <code>RUTA_DEL_CONTEXTO</code> (generalmente <code>.</code> para el directorio actual) y ejecuta sus instrucciones para crear la imagen.</p><p><strong>Opción clave:</strong> <code>-t NOMBRE[:TAG]</code> para nombrar y etiquetar la imagen construida (ej: <code>-t mi_app:v1</code>).</p><p><em>Analogy: Usar la receta para construir el plano.</em></p>
<p>¿Cuál es la <strong>primera instrucción</strong> obligatoria en un Dockerfile y qué define?</p>;<h3><code>FROM imagen_base[:tag]</code></h3><p>Define la **imagen base** sobre la cual se construirá la nueva imagen. Es el punto de partida.</p><p><em>Analogy: Elegir el plano básico (ej: imagen de Ubuntu, Node.js o Python) para empezar.</em></p>
<p>¿Qué instrucción de Dockerfile usas para ejecutar un comando **durante la construcción de la imagen** (ej: instalar paquetes, copiar archivos de configuración del sistema)?</p>;<h3><code>RUN comando</code></h3><p>Ejecuta un comando dentro del entorno de construcción. Cada <code>RUN</code> crea una nueva capa en la imagen.</p><p><em>Analogy: Hacer trabajos de construcción o instalación *mientras* creas el plano.</em></p>
<p>Quiero copiar un archivo o directorio **desde mi máquina local** (el directorio donde está el Dockerfile) **dentro de la imagen** que estoy construyendo. ¿Qué instrucción de Dockerfile uso?</p>;<h3><code>COPY origen destino</code></h3><p>Copia archivos o directorios especificados desde el contexto de construcción (tu máquina local) al sistema de archivos de la imagen.</p><p><code>ADD</code> es similar pero con funciones extra (URLs, tarballs). Para copias locales, <code>COPY</code> es preferible.</p><p><em>Analogy: Poner tu código o archivos de la aplicación *dentro* del plano.</em></p>
<p>¿Qué instrucción de Dockerfile me permite definir el **directorio de trabajo por defecto** dentro de la imagen para las instrucciones subsiguientes?</p>;<h3><code>WORKDIR /ruta/directorio</code></h3><p>Establece el directorio actual dentro de la imagen para las instrucciones <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>, <code>COPY</code>, etc. posteriores a esta instrucción.</p><p><em>Analogy: Definir la habitación principal donde trabajarás o donde se ejecutará la aplicación.</em></p>
<p>¿Qué instrucción de Dockerfile se usa para **documentar qué puertos** espera usar un servicio dentro del contenedor, aunque **no los publica** automáticamente en el host?</p>;<h3><code>EXPOSE puerto [puerto...]</code></h3><p>Informa a Docker y a quien use la imagen qué puertos el contenedor espera escuchar en tiempo de ejecución.</p><p>La publicación real al host se hace con la flag <code>-p</code> de <code>docker run</code> o en Docker Compose.</p><p><em>Analogy: Indicar qué "ventanas" tiene la casa para comunicación, pero no abrirlas aún al exterior.</em></p>
<p>Necesito establecer una <strong>variable de entorno</strong> para mi aplicación dentro de la imagen. ¿Qué instrucción de Dockerfile uso?</p>;<h3><code>ENV NOMBRE=valor</code></h3><p>Define una variable de entorno que estará disponible para los procesos que se ejecuten en los contenedores creados a partir de esta imagen.</p><p><em>Analogy: Definir ajustes o configuraciones internas de la casa (como la temperatura ideal).</em></p>
<p>Explica la diferencia entre las instrucciones <code>CMD</code> y <code>ENTRYPOINT</code> en un Dockerfile.</p>;<p>Ambas definen el comando a ejecutar al iniciar un contenedor, pero:</p><ul><li><code>CMD ["ejecutable", "param"]</code>: Es el **comando por defecto**. Se **reemplaza** si se pasan argumentos a <code>docker run</code>.</li><li><code>ENTRYPOINT ["ejecutable"]</code>: Es el **ejecutable principal**. Los argumentos pasados a <code>docker run</code> se añaden como **parámetros** a este ejecutable.</li></ul><p>Se usan a menudo juntas: <code>ENTRYPOINT</code> define el programa, <code>CMD</code> sus argumentos por defecto.</p><p><em>Analogy: <code>CMD</code> es la acción por defecto (ver TV). <code>ENTRYPOINT</code> es el programa principal (la TV) al que le pasas instrucciones (qué canal, qué volumen).</em></p>
<p>¿Por qué es necesario el concepto de <strong>Persistencia de Datos</strong> con Volúmenes en Docker?</p>;<p>Porque los **contenedores son efímeros**: cualquier archivo o dato escrito *dentro* del sistema de archivos del contenedor se **pierde permanentemente** cuando el contenedor se elimina (`docker rm`).</p><p>La persistencia (con Volúmenes) asegura que los datos sobrevivan al contenedor.</p><p><em>Analogy: Los objetos dentro de la casa desaparecen si la demueles, a menos que los guardes en un "disco duro externo" conectado.</em></p>
<p>¿Qué es un <strong>Volumen</strong> en el contexto de Docker?</p>;<p>Es un mecanismo para **conectar un área de almacenamiento** (en el host o gestionada por Docker) a un **directorio específico dentro de un contenedor**.</p><p>Permite que los datos guardados en ese directorio persistan independientemente del ciclo de vida del contenedor.</p>
<p>Nombra los **dos tipos principales de Volúmenes** utilizados por los desarrolladores.</p>;<ol><li><strong>Bind Mounts:</strong> Montan un directorio específico de la **máquina host** en el contenedor.</li><li><strong>Docker Volumes:</strong> Áreas de almacenamiento **gestionadas por Docker**.</li></ol>
<p>¿Qué tipo de volumen es ideal para **montar tu código fuente** en un contenedor durante el desarrollo, permitiendo cambios instantáneos?</p>;<h3>Bind Mount</h3><p>Porque conectan un directorio **específico y controlado por ti** en el host directamente al contenedor.</p><p>Sintaxis en <code>docker run</code>: <code>-v /ruta/en/tu/maquina:/ruta/en/el/contenedor</code>.</p>
<p>¿Qué tipo de volumen es recomendado para **bases de datos** o datos críticos en producción, ya que Docker gestiona su ubicación y optimización?</p>;<h3>Docker Volume</h3><p>Son gestionados por Docker, lo que puede ofrecer mejor rendimiento y portabilidad en entornos complejos. Su ubicación exacta en el host no es relevante para el usuario.</p><p>Sintaxis en <code>docker run</code>: <code>-v nombre_del_volumen:/ruta/en/el/contenedor</code>.</p>
<p>¿Cuál es la flag de <code>docker run</code> que se utiliza para **montar un volumen** (Bind Mount o Docker Volume) en un contenedor?</p>;<h3><code>-v</code> o <code>--mount</code></h3><p>Se usan para especificar las conexiones entre el almacenamiento persistente y los directorios del contenedor.</p><p>Ej: <code>-v /app/logs:/var/log</code> (Bind Mount), <code>-v db_data:/var/lib/mysql</code> (Docker Volume).</p>
<p>¿Por qué necesitan los contenedores de una aplicación **conectarse entre sí** (ej: backend con base de datos) y ser **accesibles desde fuera**?</p>;<p>Necesitan <strong>comunicación</strong> para funcionar como un sistema integrado (ej: el backend consulta la DB).</p><p>Necesitan ser <strong>accesibles externamente</strong> (desde el navegador, otra app, etc.).</p>
<p>¿Qué mecanismo de Docker permite que los contenedores en una red puedan **encontrarse y comunicarse usando sus nombres** en lugar de direcciones IP?</p>;<h3>Redes Definidas por el Usuario (Custom Networks)</h3><p>Creas una red con <code>docker network create</code> y conectas tus contenedores a ella con <code>--network</code>. Docker proporciona resolución DNS por nombre de contenedor/servicio dentro de esa red.</p><p><em>Analogy: Crear una calle privada donde las casas se conocen por su nombre.</em></p>
<p>¿Qué flag de <code>docker run</code> se usa para **mapear o publicar un puerto** del contenedor a un puerto de la máquina host, haciéndolo accesible desde fuera?</p>;<h3><code>-p PUERTO_HOST:PUERTO_CONTENEDOR</code></h3><p>Redirige el tráfico del <code>PUERTO_HOST</code> de tu máquina al <code>PUERTO_CONTENEDOR</code> dentro del contenedor.</p><p>Ej: <code>-p 8080:3000</code> (El servicio en el puerto 3000 del contenedor es accesible vía el puerto 8080 en el host).</p><p><em>Analogy: Abrir y etiquetar una "ventana" específica de la casa hacia el exterior (tu máquina).</em></p>
<p>Si tengo dos contenedores, <code>web</code> y <code>api</code>, conectados a una red custom llamada <code>app-net</code>, ¿cómo se conectaría el contenedor <code>web</code> al contenedor <code>api</code> en el código de mi aplicación?</p>;<p>Usando el <strong>nombre del contenedor destino</strong> (<code>api</code>) y el puerto interno que usa la API.</p><p>Ej: Una llamada HTTP desde <code>web</code> a <code>http://api:8000/endpoint</code> (si la API escucha en el puerto 8000).</p>