#separator:;
#html:true
¿Cuál es el flujo general de pasos lógicos que suele seguir un <code>Dockerfile</code>?;<ol><li>Base OS/Runtime (<code>FROM</code>)</li><li>Instalar Dependencias (<code>RUN</code>)</li><li>Configurar Entorno (<code>COPY</code>, <code>WORKDIR</code>, <code>ENV</code>)</li><li>Definir Comando de Ejecución (<code>CMD</code>/<code>ENTRYPOINT</code>)</li></ol><i>Nota: A menudo se empieza en el paso 2/3 usando imágenes base de lenguajes.</i>
¿Por qué es fundamental <b>fijar la versión</b> de la imagen base (<code>FROM imagen:tag</code> o <code>@sha256:...</code>)?;"[🔒👁️] Para asegurar <b>reproducibilidad</b> y <b>seguridad</b>. Evita roturas por cambios inesperados en la base y permite control sobre vulnerabilidades. El hash SHA256 da la máxima garantía."
¿Por qué elegir imágenes base <b>pequeñas y seguras</b> (ej. <code>-slim</code>, <code>-alpine</code>, Chainguard)?;"[🔒🏎️] Reducen el <b>tamaño final</b> de la imagen (más rápidas de transferir) y la <b>superficie de ataque</b> (menos vulnerabilidades)."
¿Cómo se <b>optimiza el caché de capas</b> de Docker al instalar dependencias para acelerar builds?;"[🏎️👁️] Ordenando las instrucciones: 1º <code>COPY</code> archivos de definición de deps (<code>requirements.txt</code>, etc.). 2º <code>RUN</code> instalación de deps. 3º <code>COPY</code> resto del código. Así, la instalación de deps solo se rehace si cambian sus definiciones."
¿Qué beneficio adicional aportan los <b>montajes de caché de Buildkit</b> (<code>RUN --mount=type=cache,...</code>)?;"[🏎️] Aceleran aún más la instalación de dependencias al reutilizar artefactos cacheados (paquetes descargados) de forma más granular, incluso si los archivos de definición cambian ligeramente."
¿Por qué se recomienda combinar comandos relacionados en una sola instrucción <code>RUN</code> (usando <code>&&</code>)?;"[🏎️👁️] Reduce el número de capas (puede mejorar ligeramente tamaño/velocidad) y mantiene la cohesión lógica. Usar <i>heredocs</i> mejora la legibilidad de scripts largos."
¿Cuál es la principal razón para usar un <b>usuario no-root</b> (<code>USER nombre_usuario</code>) en un Dockerfile?;[🔒] Mejorar la <b>seguridad</b> aplicando el principio de mínimo privilegio y añadiendo una capa de defensa en profundidad.
¿Por qué es importante instalar <b>solo dependencias de producción</b> en la imagen final?;[🔒🏎️👁️] Para reducir la <b>superficie de ataque</b>, disminuir el <b>tamaño</b> de la imagen y evitar software innecesario en producción.
¿Cómo deben manejarse la <b>información sensible</b> (secretos, claves API) al construir imágenes Docker?;[🔒] <b>NUNCA</b> copiarlos directamente a la imagen. Usar mecanismos seguros como secretos de build (build secrets), variables de entorno pasadas en tiempo de ejecución o volúmenes/montajes.
¿Cómo contribuyen <code>.dockerignore</code> y el uso específico de <code>COPY</code> a una mejor imagen?;[🔒🏎️👁️] <b><code>.dockerignore</code></b> evita enviar archivos innecesarios/sensibles al contexto. <b><code>COPY</code> específico</b> (en lugar de <code>COPY . .</code>) asegura que solo se incluyan los archivos requeridos. Ambos mejoran seguridad, velocidad de build y claridad.
¿Cuál es el propósito de la instrucción <b><code>WORKDIR /ruta/trabajo</code></b>?;[👁️] Define un directorio por defecto para las instrucciones siguientes (<code>RUN</code>, <code>COPY</code>, <code>CMD</code>...), mejorando la <b>claridad y organización</b> del Dockerfile y del sistema de archivos de la imagen.
¿Qué función cumple la instrucción <b><code>EXPOSE puerto</code></b>?;[👁️] Es puramente <b>informativa/documental</b>. Indica a los usuarios qué puerto(s) la aplicación dentro del contenedor <i>espera</i> usar. No publica el puerto (eso requiere <code>-p</code> en <code>docker run</code>).
¿Para qué se utiliza la instrucción <b><code>ENV CLAVE=valor</code></b> en un Dockerfile?;[🔒👁️] Para establecer <b>variables de entorno</b> persistentes dentro de la imagen. Útil para configurar el comportamiento del runtime o la aplicación (ej. <code>ENV NODE_ENV=production</code>).
¿Cuál es el principal beneficio de usar <b>Construcciones Multi-Etapa</b> (Multi-Stage Builds)?;[🔒🏎️] Permiten crear imágenes finales <b>muy pequeñas y seguras</b> al separar las etapas de construcción/compilación (con sus herramientas y dependencias) de la etapa final de ejecución, copiando solo los artefactos necesarios.