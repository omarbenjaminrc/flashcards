#separator:;
#html:true
¿Por qué es crucial <b>fijar la versión</b> de la imagen base en un <code>Dockerfile</code> (<code>FROM imagen:tag</code> o <code>FROM imagen:tag@sha256:...</code>)?;"Para asegurar <b>construcciones reproducibles</b>, prevenir roturas por cambios inesperados en <code>:latest</code> o tags flotantes, y mejorar el control de <b>seguridad</b>. Fijar al SHA256 ofrece la máxima garantía."
¿Por qué se recomienda usar un <b>usuario no-root</b> (<code>USER nombre_usuario</code>) dentro del contenedor y qué implica para <code>COPY</code>?;"Mejora la <b>seguridad</b> (principio de mínimo privilegio, defensa en profundidad). Al usar <code>COPY</code>, se debe asegurar la propiedad correcta de los archivos con <code>--chown=nombre_usuario:grupo</code>."
¿Cómo funciona el <b>caché de capas</b> de Docker y cómo impacta la velocidad de construcción?;"Docker almacena el resultado de cada instrucción (capa). Si una instrucción y sus entradas no cambian, reutiliza la capa cacheada. Esto <b>acelera las reconstrucciones</b> al evitar re-ejecutar pasos costosos."
¿Cuál es la técnica clave para <b>optimizar el caché de capas</b> al instalar dependencias (ej. pip, npm, mvn)?;Ordenar las instrucciones: <ol><li><code>COPY</code> archivos de definición de dependencias (<code>requirements.txt</code>, <code>package.json</code>).</li><li><code>RUN</code> comando de instalación de dependencias.</li><li><code>COPY</code> el resto del código fuente.</li></ol> Así, la instalación solo se re-ejecuta si los archivos de definición cambian.
¿Qué permiten los <b>montajes de caché de Buildkit</b> (<code>RUN --mount=type=cache,...</code>) y qué ventaja adicional ofrecen sobre el caché de capas normal?;"Permiten montar un directorio de caché <i>específico</i> para una instrucción <code>RUN</code>. <b>Ventaja:</b> Pueden reutilizar artefactos (ej. paquetes descargados) incluso si el archivo de definición de dependencias ha cambiado, acelerando aún más la instalación."
¿Para qué sirve la instrucción <b><code>WORKDIR /ruta/app</code></b> en un Dockerfile?;Define un <b>directorio de trabajo por defecto</b> dentro de la imagen. Las instrucciones siguientes (<code>RUN</code>, <code>COPY</code>, <code>CMD</code>) se ejecutan relativas a esa ruta, mejorando la <b>claridad y organización</b>.
¿Cómo se puede añadir <b>metadatos</b> a una imagen Docker y cuál es su propósito?;<ul><li>Usando <code>LABEL clave="valor"</code> (ej. para autor, versión, siguiendo estándares OCI).</li><li>Usando <code>EXPOSE puerto</code> (solo informativo, documenta el puerto esperado).</li></ul> <b>Propósito:</b> Mejorar la <b>documentación y usabilidad</b> de la imagen.
¿Qué son las <b>construcciones multi-etapa</b> (Multi-Stage Builds) en Docker y cuál es su principal beneficio?;Permiten definir múltiples etapas <code>FROM ... AS nombre_etapa</code> en un solo Dockerfile. Se usan etapas intermedias para construir/compilar, y la etapa final copia <i>solo</i> los artefactos necesarios (<code>COPY --from=etapa_anterior ...</code>). <b>Beneficio:</b> Producen imágenes finales <b>muy pequeñas y seguras</b>, sin herramientas/dependencias de construcción.
Resume los <b>beneficios generales</b> de aplicar los principios de optimización de Dockerfiles (fijar base, caché, no-root, multi-etapa, etc.).;Se obtienen imágenes: <ul><li>Más <b>seguras</b>.</li><li>Más <b>rápidas</b> de construir.</li><li>Significativamente más <b>pequeñas</b>.</li><li>Más <b>claras</b> y mantenibles (Dockerfile).</li><li>Más <b>reproducibles</b> y confiables.</li></ul>