#separator:;
#html:true
¿Cómo está estructurado el sistema de archivos de un contenedor Docker al crearse y cuál es la implicación para los datos?;Se basa en capas de imagen <b>solo lectura (read-only)</b>, con una capa superior <b>lectura/escritura (read/write)</b> específica para ese contenedor. <b>Implicación:</b> Los cambios hechos en esta capa superior son <b>efímeros</b> y se pierden si el contenedor se elimina (especialmente con <code>--rm</code>).
¿Cuál es la forma <b>incorrecta</b> (pero demostrativa) de añadir dependencias como <code>ping</code> a un contenedor y por qué no se debe usar?;Instalándolas directamente en un contenedor en ejecución (<code>apt install...</code>). <b>Por qué es incorrecto:</b> Los cambios solo persisten en la capa efímera de *ese* contenedor (y solo si no se usa <code>--rm</code> y se reutiliza con <code>start</code>/<code>attach</code>). No es reproducible ni escalable.
¿Cuál es la forma <b>correcta</b> de asegurar que las dependencias (software necesario) estén disponibles en un contenedor?;Incluyéndolas en la <b>imagen</b> durante su construcción mediante un <code>Dockerfile</code> y el comando <code>docker build -t mi-imagen .</code>. Así, cada contenedor iniciado desde esa imagen las tendrá preinstaladas.
¿Qué tipo de información es la <b>excepción</b> y <i>no</i> debería incluirse en la imagen, sino proporcionarse en tiempo de ejecución?;La <b>configuración específica del entorno</b> (variables de entorno, archivos de configuración secretos, etc.), siguiendo principios como los de 12factor.net/config. Usar <code>-e</code> o montajes para esto.
¿Cuál es la solución principal de Docker para persistir <b>datos generados por la aplicación</b> (ej. datos de BD, archivos subidos) más allá del ciclo de vida del contenedor?;Usar <b>Volumes (Volúmenes)</b> o <b>Mounts (Montajes)</b>, que conectan un almacenamiento externo (gestionado por Docker o del host) a una ruta dentro del contenedor.
¿Qué son los <b>Volume Mounts</b> (Montajes de Volumen) y por qué son la opción preferida para datos de aplicación?;Son áreas de almacenamiento <b>gestionadas por Docker</b> (ubicadas en <code>/var/lib/docker/volumes/...</code> o similar). <b>Preferidos porque:</b> son independientes del host, gestionables vía Docker, suelen tener mejor rendimiento en Win/Mac, y son fácilmente compartibles.
¿Cómo se usa un <b>Volume Mount</b> con <code>docker run</code> (sintaxis corta y larga)?;Corta: <code><b>-v nombre-volumen:/ruta/contenedor</b></code><br>Larga: <code><b>--mount source=nombre-volumen,destination=/ruta/contenedor</b></code> (El volumen se crea si no existe).
¿Qué es un <b>Bind Mount</b> (Montaje Bind) y cuándo podría usarse?;Mapea directamente un <b>archivo o directorio del sistema anfitrión (host)</b> a una ruta dentro del contenedor. <b>Usos comunes:</b> Montar código fuente en desarrollo para live-reloading, compartir archivos de configuración específicos del host.
¿Cómo se usa un <b>Bind Mount</b> con <code>docker run</code> (sintaxis corta y larga) y cuáles son sus posibles desventajas?;Corta: <code><b>-v /ruta/del/host:/ruta/contenedor</b></code><br>Larga: <code><b>--mount type=bind,source=/ruta/del/host,destination=/ruta/contenedor</b></code><br><b>Desventajas:</b> Acoplamiento al host, posibles problemas de permisos, rendimiento potencialmente inferior en Win/Mac.
¿Qué son los <b>tmpfs Mounts</b> y para qué <i>no</i> deben usarse?;Son montajes que existen únicamente en la <b>memoria RAM</b> del host. Los datos <b>NO PERSISTEN</b> al detener el contenedor. Ideales para datos temporales/sensibles, <b>NO usar para datos de aplicación que deban conservarse</b>.
¿Qué propósito demuestran las opciones <code>-it</code> (<code>--interactive --tty</code>) en <code>docker run</code>?;Permiten una <b>sesión interactiva</b> con el contenedor, conectando tu terminal al shell o proceso principal dentro de él.
¿Qué efecto tiene la opción <code>--rm</code> en <code>docker run</code> y qué ayuda a ilustrar pedagógicamente?;<b>Elimina automáticamente el contenedor</b> cuando este se detiene. <b>Ilustra:</b> la naturaleza efímera de la capa escribible del contenedor si no se usan volúmenes/montajes para persistir datos.
¿Qué permiten las opciones <code>--name mi-contenedor</code> + <code>docker start mi-contenedor</code> + <code>docker attach mi-contenedor</code> y qué demuestran (aunque no sea la mejor práctica)?;Permiten <b>nombrar</b>, <b>reiniciar</b> y <b>reconectar</b> a un contenedor específico detenido (sin <code>--rm</code>). <b>Demuestran:</b> que el estado de un contenedor (incluyendo su capa escribible) puede persistir temporalmente si se gestiona manualmente, pero no es la forma ideal para dependencias o datos.
¿Para qué sirve el comando <code>docker volume create mi-volumen</code>?;Para <b>crear explícitamente un volumen gestionado por Docker</b> llamado <code>mi-volumen</code> antes de usarlo en un comando <code>docker run</code>. Es una buena práctica para la gestión de volúmenes.
¿Para qué se usaría <code>docker container ps -a</code> en el contexto de la persistencia?;Para <b>verificar que un contenedor nombrado</b> (y ejecutado sin <code>--rm</code>) todavía existe en estado detenido (<code>Exited</code>) después de salir de él, confirmando que su estado no se perdió inmediatamente.
¿Qué información útil sobre persistencia podríamos obtener con <code>docker container inspect mi-contenedor</code>?;Mostraría detalles sobre los <b>montajes</b> configurados para ese contenedor (tipo, origen, destino), ayudando a verificar si los volúmenes o bind mounts están correctamente asociados.
¿Qué operación potencialmente riesgosa permiten las opciones <code>--privileged --pid=host</code> (usadas con <code>justincormack/nsenter1</code>) y por qué se usó en el ejemplo?;Permiten ejecutar un contenedor con <b>altos privilegios y acceso al espacio de procesos del host</b> (la VM de Docker Desktop). Se usó para <b>explorar el sistema de archivos interno de la VM</b> y localizar dónde Docker guarda físicamente los datos de los volúmenes (ej: en <code>/var/lib/docker/volumes/...</code>). ¡Usar con extrema precaución y solo con imágenes de confianza!